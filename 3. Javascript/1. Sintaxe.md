# Javacript: Introdução

## História:

Tudo é uma evolução/transformação, nada foi criado no zero. Com o surgimento do HTML e do HTTP, especialistas começaram a interagir e evoluir a ferramenta até que foi criada a Netscape, uma empresa importantíssima que financiou a criação do Live Script, uma linguagem scriptada que focava em dar "dinâmica" à pagina estática. Em função da popularidade da liguagem de programação Java, foi trocado o nome de Live Script para JavaScript (ambas são baseadas em "C", mas completamente diferentes). Para evitar copias e criar um padrão no mercado, a Netscape realizou uma parceria com a Ecma International e criou o EcmaScript, que é o JavaScript usado pelas pessoas atualmente. A versão mais atual do Javascript é a ES2022 (EcmaScript 2022).

O Javascript, no contexto histórico, foi criado para melhorar o HTML e na atualidade ainda é usado para tal, regulando o comportamento dos sites e fazendo uso do Unicode charset. Contudo, com a evoulação da linguagem ele passou a poder também ser usado fora dos web browsers, atuando no backend de server-side aplications. Existem ainda JavaScript Frameworks, eles são ambientes de devesenvolvimento que ajudam os developers a renderizar e criar coisas (eles facilitam a implementação de coisas ao fornecer uma "estrutura" própria).

No passado e ainda hoje utiliza-se Jquery. Jquery é uma library de JavaScript que foi feita para simplificar e otimizar a manipulação HTML DOM, além de ser capaz de fazer animações em CSS e receber e enviar informações de/para bancos de dados através do Ajax. OBS: DOM = Document Object Mode. Ele permite que você trabalhe diretamente com os elementos do html (div, h3, span, etc) sem precisar "converter" ou ter trabalho a mais em JavaScript.

Atualmente exitem ferramentas/frameworks que são muito melhores que Jquery (como Angular, React, Svelte), todos eles facilitando a modificação e implementação de código em websites. As principais features de um framework são: Rendering, Data handling e Event handling. Aliás, enquanto python usa a "Snake case" (abacate_bonito), JavaScript usa a "Pascal case" (abacateBonito ou AbacateBonito)

## Aprendizado:

O trabalhoso não é entender a sintaxe, é desenvolver o pensamento criativo de como resolver um problema real com essa sintaxe.
Você deve desenvolver a capidade de transformar um texto/pedido em instruções, como se fossem uma recita. Depois basta "seguir" essa recita na linguagem de programação e faze com que cada passo se conecte com o anterior.

## "use strict":

É uma string que você sempre deve escrever na liha 1 do seu arquivo .js. Basicamente é responsável por "ativar" funcionalidades modernas do javaScript.

## Erros:

Javacript é uma linguagem interpretada. Isso significa que, em troca de ter uma sintaxe mais agradável e flexivel ele vai ter uma performance inferior. Em se tratando dos erros que você encontrar quando escrevendo em javascript os principais são:

- **syntax errors**: você escreveu errado e/ou não seguiu a "ortografia" da linguagem.
- **Logical errors**: você emplementou o código em uma logica fundamentalmente errada. O compilador/interpretador vai funcionar mas não do jeito que deveria.

## Operators:

São simbolos que você pode utilizar para fazer a interação entre duas variáveis. Existem os operadores matemáticos (que servem para somar, subtrair, etc), os lógicos (Que servem para comparar duas variáveis) entre outros. Alguns operadores comuns são encontrados abaixo:

- `!=` (diferente)
- `**` (pontenciação)
- `%` (resto da divisão)

- `>=` (maior ou igual)
- `<=` (menor ou igual)
- `==` (igual lógico)
- `===` (estritamente igual. Também lógico)

- `x += 5` é o mesmo que `x = x + 5`
- `x /= 5` é o mesmo que `x = x / 5`
- entre outros

## Variables:

### declaração:

A nossa básica é: Variables são "containers" para values. Variables (e objects) Não são seu values, são "espaços" onde eles estão armazenados.
Existem 3 formas de declarar uma variável (criar uma "caixa" vazia que armazena os valores que você quer):

- `var`: Modo antigo. É confuso mas tem suas vantagens (ex: hoisting e multiplas declarações para uma mesma variável).

  ```js
  var count = 1;
  var count = 2; //É permitido
  ```

- `let`: Modo "novo". Faz o mesmo que o var mas não tem hoisting nem é permitido fazer multiplas declarações para uma mesma variável.

  ```js
  let count = 1;
  let count = 2; // É proibido
  count = 2; // É permitido
  ```

- `const`: Cria a variável do mesmo jeito, mas o value/valor atrelado à ela não poderá variar. É recomendado usar quando os dados são "estáticos" (tipo um botão).

  ```js
  const count = 1;
  count = 2; // É proibido
  ```

Como regra geral, sempre declare variáveis como `const` a menos que você saiba que elas vão mudar, nesse caso use `let`.

### Escopos de declaração:

Em JS existem três scopes:

- **Global Scope** (a variável pode ser usada em todo o código)
- **Function Scope** (a variável só é usada dentro de funções)
- **Block Scope** (variáveis criadas dentro de "{ chaves }" (block) não podem ser acessadas fora dessa block. Cada bloco é único e não precisa de indentificação)

### Data Types:

#### Number:

Esse Data Type é igual ao "float" do python, com 64 bits de comprimento. Os valores em notação científica também são do datatype "number". Ex: `const number3 = 3e5 // 3* 10^5`

#### String:

Em JS as aspas normais ('') e as duplas ("") são tratadas como iguais sendo usadas para declarar strings.
As aspas "reversas" (\`\`) são usadas para fazer **template strings** (template Literals). Ex: let x = \`Posso usar o valor dessa ${variavel}\`;

#### Boolean:

Só exitem dois valores possíveis, true ou false. Normalmente usada em alguma expressão com operadores logicos.

#### Symbol:

É um valor único que você obtem através de uma string. Você não pode ver o valor/conteúdo de uma symbol, é como se fosse um uid.
Dois symbols de uma mesma string não são iguais. O objetivo dos symbols é tratar dados de maneira mais discreta (privacidade) mas não são "fortes" o suficiente para tal, sendo necessário usar proxies e outras tecnologias em um app profissional.

#### Objects:

Objects armazenam os dados em key/value pairs. As keys tem que ser strings e os values podem ser qualquer outros data type (até mesmo outros objects ou alguma função. São criados ao usar chaves ({}).

```js
let object = {
  key1: "value",
  key2: 5,
};
```

#### Undefined:

É a variable global que representa a não existênicia de dados. Quando você faz `let x;` Você está dizendo que x existe, mas não está dando um valor para ele.
Até que um valor seja atribuido à x ele será reconhecido como "undefined". A keyword `void` pode ser usada para ignorar o output associado a uma expressão e então retornar "undefined". A sintaxe é `void <expression>`.

```js
function f() {
  document.body.style.backgroundColor = "red";
  document.body.style.color = "white";
} //a função é totalmente funcional
let vari = undefined === void f(); //Como "void f()" é undefined então vari = true
alert(vari);
```

#### Null:

Normalmente é usada para indicar falta de "indentidade", ou então quando uma variável vai ter um valor no futuro, mas não tem agora. Por exemplo `let x = null;`

### Hoisting:

Hoisting se refere ao processo, realizado pelo interpretador da linguagem, de mover as Declarações de funções, variáveis e classes para o topo de seus respectivos escopos, antes de serem executados.

#### Em funções:

```js
//O "correto" seria escrever a função primeiro e depois "chamar" ela, mas:

catName("Tiger");

function catName(name) {
  console.log("My cat's name is " + name);
}
//O código acima roda, mesmo que a função seja chamada antes de ter sido declarada. Output: "My cat's name is Tiger"
```

#### Em variáveis:

Basciamente só quando você declara variáveis com o "var" que o hoisting é possível, porém diferente do modo que acontece com as funções.

```js
console.log(num);
/* Vai retornar 'undefined' (e não 6), porque o hoisting feito pelo var é de "declaração", ou seja, ele só declara a variável "num"
    (e como não atribui um valor a ela, ela fica como undefined) */
var num = 6; // Initialization and declaration.
console.log(num); // vai retornar/printar 6 pois é executada depois da linha de declaração e Atribuição.
```

## Condicionais:

No JS clássico existem 2 modos de fazer condicioais

1. If..Else

```js
if (choice === 'sunny' && temperature < 86) { //após o if, entre paranteses está a condição. Se ela for verdadeira o bloco de código é executado
//OBS: && = AND e || = OR
//some code
} else if (choice === 'sunny' && temperature >= 86) { //else if, você já sabe como funciona
//other code
} else {
break;
}
```

2. Switch..Case

```js
let variavel = 50;
switch (typeof variavel) {
  case "number":
    alert("1");
    break;
  case "string":
    alert("2");
    break;
  default:
    //default code
    break;
}
```

3. Operador ternário

```js
let a = "Abacte";
let b = a === "Coxinha" ? "yes" : "no";
```

## Loops/Laços:

1. For

```js
for (let i = 0; i < 5; i++) {
  console.log("ABACATE");
}
```

2. While

```js
let i = 0;
while (i < 5) {
  console.log("ABACATE");
  i++;
}
```

3. Do..While

```js
let i = 0;
do {
  console.log("ABACATE");
  i++;
} while (i < 5);
```

- 4. For..In (iteração dentro de uma coleção/objeto)

```js
const a = {
  type: "a",
  id: 5031,
};
for (let key in a) {
  console.log(a.id);
  //vai dar o resultado duas vezes porque tem 2 keys
}
```

- 5. For..of (iteração dentro de arrays)

```js
const cores = ["abacate", "2"];
for (let cor of cores) {
  console.log(cor);
}
```

## Functions:

São blocos de código indentados (dentro de chaves {}) e que só são executadas quando são invocadas (algum outro comando ou evento a executa) ou quanto se auto-invocam (executam "automaticamente"). Você deve criar funções/blocos de códigos auto contidos para seus propósitos (não crie funções muito grandes ou que acessam muitas coisas, dê prioridade à criar outra funções).

```js
function convertToFahrenheit(celsius)
{
return ((9/5) \* celsius) + 32
let variable = "abacate" === "coxinha" //A função vai ignorar essa linha pois ela esta depois do "return" e no mesmo bloco (de codigo), ou seja, vai ser pulada/ignorada.
}
alert(convertToFahrenheit(5))
alert(variable) //como "variable" não foi atrubida, nada acontece.
```

### Arrow functions:

É uma notação mais consisa que visa compactar a declaração de funções. Outro detalhe é que arrow functions não tem um "this." próprio, isso significa que a função não consegue entender/encontrar o "contexto" em que está. Graças a essa funcionalidade arrow functions são normalmente usada para declarar funções de callback (que são passadas para outras funções como parâmetro para serem executadas no final da execução da primeira).

```js
const array = [
  { id: 1, name: "a" },
  { id: 2, name: "b" },
];
console.log(
  array.find((array) => {
    return array.name === "a";
  })
);
```

### Rest parameters:

O símobolo `...` pode ser tanto **rest paramenter** quanto **spread operator**, dependendo do contexto.

É **rest parameter** quando você o usa como argumento. Basicamente é utilizado para passar argumentos "infinitos" para uma função.

```js
function sumAll(...args) {
  // args is the name for the array
  let sum = 0;
  for (let arg of args) {
    sum += arg;
  }
  return sum;
}
alert(sumAll(1)); // 1
alert(sumAll(1, 2)); // 3
alert(sumAll(1, 2, 3)); // 6 ##
```

É **spread operator** quando você usar ele na atribuição de coisas. Basicamente serve para copiar/concatenar/manipular objects e arrays.

```js
let arr = [3, 5, 1];
let arr2 = [8, 9, 15];
let merged = [0, ...arr, 2, ...arr2];
alert(merged); // 0,3,5,1,2,8,9,15
```

### Callbacks:

Callback é um termo utilizado normalmente quando se trabalha com async/await, mas, basicamente, consiste em chamar um função dentro de outra função, criando uma relação de dependencia/sequencia lógica de eventos.

```js
function preProducao(arg1, iniciar_producao) {
  if (arg1 === "iniciar") {
    iniciar_producao();
  }
}

function initProducao() {
  alert("doing something");
}

preProducao("iniciar", initProducao);

//repare que a função que inicia a produção só começa/ocorre quando a função "preProducao" da a liberdade/ordem de iniciar.
```

### Recursion and stack:

Recursividade é um programming pattern usado para deixar o código mais limpo ou fazer algo mais simples de intender. Consiste basicamente em, dentro de uma função, chamar a própria função. Vejamos dois modos diferentes de criar uma mesma função:

```js
//Com o for loop
function pow(x, n) {
  let result = 1;
  for (let i = 0; i < n; i++) {
    result *= x;
  }
  return result;
}
```

```js
//Com recursividade
function pow(x, n) {
  if (n == 1) return x;
  else return x * pow(x, n - 1);
}
```

Mais detalhadamente, quando uma função é executada, as informações dela (como o valor de this ou de outras variáveis) são armazenadas em uma data structure especial chamada de **execution context**.
Quando uma função é chamada dentro de outra função (caso da recursividade), o execution context mais externo é pausado e um novo é criado. Essa dinâmica de "pausar" e criar outro em cima funciona na base de stacks (pilhas).
Basta perceber que o primeiro execution context vai ser o ultimo a ser retornado pois todos os outros que vieram depois dele precisam ser "retirados" antes de modo que o mais externo possa voltar a ser executado.
Como criar execution contexts demanda memória, você não pode se dar ao luxo de fazer isso várias vezes. No caso da função "pow" vão ser criadas "n" execution contexts.
Todas as funções recursivas podem ser reescritas como loops, e loops consumem/precisam de menos memória. Entretando contruir um loop complexo é uma tarefa mais difícil.

### Scheduling:

funções que permitem que outras funções rodem depois de um certo tempo. Serve para simular uma "chamada assincrona".

- setTimeout: permite rodar uma função depois de um certo tempo.

```js
function sayHi() {
  alert("Hello");
}

setTimeout(sayHi, 1000);
//1000ms = 1 segundo
```

- setInterval: permite rodar uma função dado um periodo, se repetindo regularmente.

```js
let timerId = setInterval(() => alert("tick"), 2000);
//vai rodar a cada 2 segundos. Além disso é infinito, ou seja, não vai parar.
// Temos que parar "manualmente" usando o setTimeout e clearInterval.
setTimeout(() => {
  clearInterval(timerId);
  alert("stop");
}, 5000);
```

### Function biding:

Basicamente, quando queremos passar uma key/value de um objeto em uma função(callback) e esse key/value usa o "this", o "contexto" do "this" é perdido.
Em outras palavras, a função que recebe um objeto como argumento não faz a minima ideia sobre o que "this" é.
Para resolver isso podemos usar um wrapper, ou seja, criar uma "lambda function" que salva o "contexto" do this e então passa ele para a outra função. Esse metodo tem vulnerabilidades, sendo recomendado usar o method bind.

O method bind basicamente vai pegar uma função, "juntar" o seu contexto(objeto ou qualquer outra coisa que o .this se refere) e então criar um objeto especial que pode ser chamado(callback) como uma função.

```js
function hash(arguments) {
  return arguments[0] + "," + arguments[1];
}

//decorator
function cachingDecorator(func, hash) {
  let cache = new Map();
  return function () {
    let key = hash(arguments);
    if (cache.has(key)) return cache.get(key);
    else {
      let result = func.call(this, ...arguments);
      cache.set(key, result);
      return result;
    }
  };
}

//objeto com o método que ser quer fazer o cache
let worker = {
  slow(min, max) {
    console.log("Working...");
    return min + max;
  },
};

worker.slow = cachingDecorator(worker.slow, hash);
let start = new Date();
worker.slow(3, 5);
let end = new Date();
console.log(`Demora: ${end - start}ms`);

start = new Date();
worker.slow(3, 5);
end = new Date();
console.log(`Demora (cached): ${end - start}ms`);
```

Esse exemplo é um pouco mais complexo. Se tiver dificuldade de entender o porque da utilização da função hash(), dê uma olhada [aqui](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments).

## Objects:

Analogia é perfeita: Um carro é um objeto. - Todos os carros tem as mesmas properties (cor, tamanho, peso) mas seus values são diferentes - Todos os carros tem os mesmos methods (ligar, freiar, etc) mas eles são acionados em momentos diferentes.

É uma boa prática usar a keyword "const" para definir/declarar um objeto, porém objetos em JS são especiais por serem dinâmicos (podem ser alterados) e portanto isso fica a critério próprio.
Você pode declarar/criar um objeto de duas formas:

##

let user = new Object(); // "object constructor" syntax
let user = {}; // "object literal" syntax

##

Você pode acessar o valor de uma propertie de duas formas: - objectName.propertyName (ex: car.color) - objectName["propertyName"] (ex: car["type"])
Methods são as funções/ações que aquele objeto possue/cotem e portanto pode executar. Basta criar/declacar o value de uma key como uma function:

##

const person = {
firstName: "John",
lastName : "Doe",
id : 5566,
fullName : function() {
return this.firstName + " " + this.lastName; // repare na indentação
}
};

##

➽ Computed properties: Você pode dar o nome de uma key de forma dinâmica (mais não pode acessar esse nome de forma dinâmica).

##

    let fruit = prompt("Which fruit to buy?", "apple");
    let bag = {
      [fruit]: 5, // o nome da key é o valor da variável "fruit"
    };
    alert( bag.apple ); // Porém para fazer o alert nos precisamos saber e especificar qual o nome da key ("bag.[fruit]" não funciona).

##

➽ Criando objetos dinamicos com "this":
Você pode usar a keywork "this" dentro de um method de modo a receber um valor do prompt. Depois de chamar esse método, você pode armazenar esse valor "dinamicamente" como um value. Dentro de um objeto.
##Ex:
let person = {
name: this.name,
age: this.age,
email: this.email,
readData(){
this.name = +prompt("Diga seu nome");
this.age = +prompt("Diga sua idade");
this.email = +prompt("Diga seu email");
}
};
person.readData(); //vai fazer os prompts e pegar os dados

    if(person.age<18){
    	alert(`Olá ${person.name}, infelizmente você não pode entrar =(`);
    }else if(person.age>75){
    	alert("Claro que você também pode usar esses dados para alterar o HTML");
    } else{
    	alert("ABACATE");
    }

##

➽ “for…in” loop:
Basicamente você pode iterar dentro de um objeto/array. No caso dos objetos é importante prestar atenção na sintaxe para diferenciar as keys dos values:

##

let user = {
name: "John",
age: 30,
isAdmin: true
};

for (let key in user) {
// keys
alert( key ); // name, age, isAdmin
// values for the keys
alert( user[key] ); // John, 30, true
}

##

➽ Copiando objetos:
Basciamente se você tem um objeto e você cria outra variável e iguala ele a esse objeto, você não está fazendo uma cópia independente, está criando uma nova referencia para o objeto.

Para efetivamente clonar um objeto pode-se usar o method "Objct.assign": ##
const oldObj = { abacate: 1, sim: false };
const newObj = Object.assign({}, oldObj); //{} significa que copia todo o objeto.
console.log(oldObj)
console.log(newObj) ##
➽ Object.keys, values, entries:
Como objects são bastante flexiveis e podem se tornar complexos, existe uma "entidade" chamada de Object que se refere a estrutura do objeto.
Object.keys(obj) retorna uma array com as keys.
Object.values(obj) retorna uma array com os values.
Object.entries(obj) retorna o key/value pair em forma de array.
E como o resultado desses methods são arrays, você pode fazer uma iteração sobre eles.

➽ Object destructuring:
Consiste em "desmanchar" (não destruir) partes de um objeto e atribuir a novas variáveis. A sintaxe básica é: "let {var1, var2} = {var1:…, var2:…}". Mas praticamente usa-se:

## Como funciona:

    let options = {
      title: "Menu",
      width: 100,
      height: 200
    };

    let {title, width, height} = options;

    alert(title);  // Menu
    alert(width);  // 100
    alert(height); // 200

##

## Exemplo mais útil:

    let options = {
      size: {
        width: 100,
        height: 200
      },
      items: ["Cake", "Donut"],
      extra: true
    };

    // destructuring assignment split in multiple lines for clarity
    let {
      size: { // put size here
        width,
        height
      },
      items: [item1, item2], // assign items here
      title = "Menu" // not present in the object (default value is used)
    } = options; //repare que options é nome do objeto base

    alert(title);  // Menu
    alert(width);  // 100
    alert(height); // 200
    alert(item1);  // Cake
    alert(item2);  // Donut

##

➽ Factory function:
É uma função que cria um objeto. ##
function abc(prop1, prop2, prop3){
return {
keyUm: prop1,
keyDois: prop2,
keyTres: prop3
}
}
const obj1 = abc(1, 2, 3)
console.log(obj1) ##

➽➽➽ Constructor Functions:
Também é utilizada para criar objetos, porém ela é como se fosse um "classe" do python (um blueprint para objetos).
Utiliza o "new" para criar um elemento dessa "classe".
Normalmente constructor functions começam com letra maiúsculas para se diferenciar.
Repare que, enquanto as factory functions usam "return" para se referir aos seus parâmetros, uma constructor function utiliza o "this." para se referir ao seus parâmetros ##
function objMaker(prop1, prop2, prop3){
this.keyUm = prop1,
this.keyDois = prop2,
this.keyTres = prop3,
this.methodUm = function(){
console.log("methodUm")
};
}
//Até agora só criamos a "classe", agora temos que efetivamente criar o objeto.
const obj1 = new objMaker("Abacate","ABACATE","a b a c a t e");
//repare que como estamos usando um "constructor" temos que usar a keyword "new"
console.log(obj1); ##

Exemplo de uso: ##
function exibirStr(obj){
for (let key in obj){
let value = obj[key];
if (typeof(value) === "string"){
console.log(key, value)
}
}
}
// O "pulo do gato" é perceber que "key in obj" vai pegar a keys do objeto e que "obj[key]" se refere ao **value** de cada key.
// Tipo, em momento nenhum em "obj[key]" nos escrevemos "value", mas no final é o que obtemos.
const abacate = {
string1: "asasa",
string2: "495485",
number1: 9,
boolean1: true
}
exibirStr(abacate) ##

Usando a keyword "new" você pode criar uma variável como um objeto de um tipo específico. Ex: ##
const x = new String(); // Declares x as a String object
const y = new Number(); // Declares y as a Number object
const z = new Boolean(); // Declares z as a Boolean object
const w = new Date(); // Declares z as a object (called Date) ##

➽ OOP: Quando você usa objetos para representar entidades(funções, uma parte da memória, etc) você está realizando/fazendo: object-oriented programming.
Essa abordagem é versátil e amplamente utilizada por programadores. É como se fosse "o jeito de certo de calçar um sapato".
Você pode calçar de diferentes formas, mas noramlmente você vai querer/preferir calçar do "jeito certo".
Isso é tão verdade que foi daí que o conceito de Design patterns foi criado. Isso basicamente se refere a um conjunto de estratégias/modos de resolver problemas comuns/recorrentes usando OOP.
Design patterns === "how to solve recurring problems". Livro: "Design Patterns: Elements of Reusable Object-Oriented Software"

➽ Chaining: É quando você faz "obj.prop1.prop2.method1.method2", tipo, você vai fazendo vários ".algumaCoisa" seguidos. Isso pode ser útil em algumas situações.
Por exemplo, existem situações onde vamos precisar usar o número da casa de um usuário através de: "user.adress.street.number". Reparem que tem 4 properties aí.
Basciamente para que você possa usar chaining você deve rotornar o próprio objeto (e deixar para fazer o output separadamente), de modo que o próximo ".algumaCoisa" vai se referir ao objeto recem alterado. Usa-se "return this";
---> Optional chaning: As vezes, alguams informações são opcionais, de modo a não existencia delas faz o código parar por causa do erro. É melhor retornar undefined que parar todo o programa.
Tipo, no exemplo anterior, pode ser que o user tenha dado o número da casa dele, mas não tenha dado a rua, isso vai gerar um erro que vai parar todo o código. Não queremos isso.
Para evitar o erro, e retornar "Undefined", precisamos usar o operador "?.". Ele SÓ DEVE ser usado quanto uma property possa ser nula.
Ex: "user.adress.street?.number". Dessa forma, a obtenção de "street" vai ser opcional, de modo que se ELE não existir, o código simplismente retorna undefined.
Repare que é só ele. Se user, adress ou number não existirem, o código vai dar erro de qualquer jeito. Então, o que fazer? Usar "?." nos elementos certos e fazer um código limpo.
O elemento que está antes(a esquerda) do "?." deve existir/ser declarado, so não precisa ter um valor. O "?." não pode ser usado para ler valores, tipo, deixar a entrada de um parâmetro como opcional. Essa "funcionalidade" existem em frameworks e no JS através de outras formas.

➽ JSON: JavaScript Object Notation foi criada, como o nome ja diz, para se transmitir o conteúdo de objetos do javaScript através da internet(HTTP). Com o passar to tempo a formatação se formou padrão para transmissão de dados na internet e é usada em outras linguagens.
No javaScript, JSON basicamente é a conversão de um objeto para uma string, com uma formatação especial. Para fazer essa conversão usamos JSON.stringify(obj);
Esse method ignora certas properties, como methods, symbolic keys/values e o null.
##Ex:
let student = {
name: 'John',
age: 30,
isAdmin: false,
courses: ['html', 'css', 'js'],
wife: null
};

    let json = JSON.stringify(student);

    alert(typeof json); // we've got a string!

    alert(json);
    /* JSON-encoded object:
    {
      "name": "John",
      "age": 30,
      "isAdmin": false,
      "courses": ["html", "css", "js"],
      "wife": null
    }
    */

##

Para fazer o caminho inverso (JSON -> object "nativo") usamos: JSON.parse.

##

    let userData = '{ "name": "John", "age": 35, "isAdmin": false, "friends": [0,1,2,3] }';
    let user = JSON.parse(userData);
    alert( user.friends[1] ); // 1

##

➽ Garbage collection:
Diferente da linguagem C, onde a a memória deve ser monitorada e controlada cautelosamente, o javaScript possue um algorítimo interno que realiza limpeza de memória de modo a "deletar" partes do código que são/ficam inúteis.
Em JS objetos(quase tudo) são mantidos na memória enquanto eles são "alcançaveis" pelo "root" do JS, que é chamado de <global>.
Ou seja, se você diz que algo é null e ele não é percebido pelo <global> (não é passado como argumento, não serve de base para uma variável, etc), então ele será deletado.
E, analogamente, se algo é usado definido como null, é passado como parâmetro E tem conexação com o <global> então ele não será deletado.
Importante notar a utilização do "E" na ultima linha pois, não basta que o objeto esteja ligado à outro, ele TAMBÉM precisa estar ligado até o <global>, otherwise ele e os outros objetos que estão ligados à ele seriam "Unreachable islands"

⚪ Prototypes & inheritance ⚪

➽ Prototypal inheritance:
É um modo/metodo em programação no geral que permite estender funcionalidades/objetos existentes.
Imagine que você tem um objeto chamado de user e que você quer criar outros 2: admin e guest. Independente de como você vai criar esses objetos ambos vão ser users, concorda?
Dessa forma podemos usar o objeto user que já existe e estender ele de modo a reusar algumas partes dele e implementar outras partes dentro de cada objeto.

Em JS existe um propriedade escondida dos objetos chamada de [[Prototype]] que aponta para "null" ou para outro objeto.
Basicamente quando você cria um objeto, [[Prototype]] é como se fosse o DNA herdado do objeto. Como, naturalmente objetos não herdam caracteristicas de outros objetos, logo [[Prototype]] é naturalmente null.
Para mudar o valor de [[Prototype]] e fazer ele apontar para outro objeto, podemos usar o **proto**. Vamos usar ele nesses exemplos iniciais, porém ele está em desuso
##Ex:
//objeto "inicial"/acestral
let animal = {
eats: true,
walk() {
alert("Animal walk");
}
};
//objeto "descendente". Queremos que ele herde as properties de "animal"
let rabbit = {
jumps: true,
**proto**: animal //basta passar um link/DNA do objeto "animal" e agora o obj "rabbit" também possue essas properties
};
//Outro objeto. Uma espécie de coelho. Ele é claramente um coelho E um animal
let longEar = {
earLength: 10,
**proto**: rabbit //como rabbits já tem o "DNA" de um animal, basta ter o DNA do "rabbit"
};

    longEar.walk(); //Naturalmente não tem property "walk", é pega do obj "animal"
    alert(longEar.jumps); //Naturalmente não tem property "jump", é pega do obj "rabbit"

##

O "this" não é agetado pelo [[Prototype]], ele sempre vai se referir ao objeto antes do ponto.
Em loops, se você fizer ele usando "Object.keys(obj)" você só verá as properties da "geração atual" (propria de obj) mas se você fizer o loop for..in ele vai passar por todos as properties, até as herdadas.

➽ F.prototype:
Você também pode herdar properties sem usar o **proto**. Basta usar a "new" sintax e usar o method ".prototype"
##Ex:
//obj "original"/ancestral
let animal = {
eats: true
};

    //constructor function.
    function Rabbit(name) {
      this.name = name;
    }

    //dizendo que os objs criados apartir constructor function "rabbit" são descendentes de "animal"
    Rabbit.prototype = animal;

    let rabbit = new Rabbit("White Rabbit"); //criando um objeto "diferenciado"
    alert( rabbit.eats ); // true

##

OBS: existe uma "property universal" chamada de "constructor", tal que a seguite igualdade é verdade:
F.prototype = { constructor: F }
É tipo "ln(x)" e "e^x", são a mesma coisa, só que escritas de maneiras diferentes.

➽ Substitutos do **proto**:
Como citado, o **proto** está em desuso e existem métodos mais modernos de se definir o prototype de um objeto:
Object.create(ancestral, [descriptors]) – cria um obj vazio com o prototype do obj "ancestral"
Object.getPrototypeOf(obj) – returns the [[Prototype]] of obj.
Object.setPrototypeOf(obj, ancestral) – sets the [[Prototype]] of obj to "ancestral".

##Ex da sintaxe:
//obj "acestral"
let animal = {
eats: true
};

    // criando um novo obj, vazio, como mesmo DNA/properties que "animal"
    let rabbit = Object.create(animal);
    //repare na utilização da "entidade" "Object".

    alert(rabbit.eats); // true
    alert(Object.getPrototypeOf(rabbit) === animal); // true
    Object.setPrototypeOf(rabbit, {}); // change the prototype of rabbit to {}

##

Com esses methods podemos fazer uma cópia "real" (ao usar o "...obj" só copiamos os valores):

##

let clone = Object.create(Object.getPrototypeOf(obj1), Object.getOwnPropertyDescriptors(obj1));

##

## Classes:

➽ syntax e conceitos básicos
Classes são um conceito utilzado em OOP que serve para criar objetos padronizados/com um conjunto inicial de dados semelhantes.
Sintaxe:
class MyClass {
// class methods
constructor() { ... }
method1() { ... }
...
}
Apartir daí basta fazer: let objeto = new Myclass(<args>); para criar um objeto.
O objetivo das classes é focar mais na utilização dos methods. Uma observação importante é que: você não deve colocar virgulas para separar os methods.
O method fundamental das classes é o "constructor". É dentro dele que você coloca as "key/values" que o objeto vai ter.
Por exemplo, se o objeto vai conter uma key chamada de name, podemos fazer:

##

class User {
constructor(name) {
this.name = name;
}
sayHi() {
alert(this.name);
}
}

let user = new User("John");
user.sayHi();

##

Classes são uma maneira mais simples e versátil de se usar constructor function (que já foram citadas no caṕitulo sobre objetos). Na realidada, uma classe é uma constructor function que possue um prototype.

OBS: dentro de uma classe você também pode criar key/values diretamente, mas isso é "restritivo" uma vez que esse mesmo valor de se repete para todos os objetos.

---> static properties: São properties que não são de um objeto que pertence a classe, mas sim a toda a classe. Pode-se dizer que são properties que todos os objetos tem porque a própria classe o tem.
Para criar ele dentro da classe, você usa a keyword static (static propNova = "Abacate") e para criar ele "fora" da classe basta você fazer "classe.propNova = 'Abacate'"

➽ Importância das arrow functions:
Como já sabemos, o "this" pode perder o "contexto" em algumas situações(quanto tentamos fazer o código responsível/moldável).
Juntando isso ao fato de que classes são baseadas em methods, temos um problema! Correto?
Não, basta você usar arrow functions ao criar os methods (não o constructor) que o "contexto" não é perdido.
##Ex:
class Button {
constructor(value) {
this.value = value;
}
/_ versão 1
click() {
alert(this.value);
}
_/
//versão ideal
click = () => {
alert(this.value);
}

}

let button = new Button("hello");

setTimeout(button.click, 1000); // se a versão 1 fosse a ativa, ocorreria perda de contexto

##

➽ getters/setters: Methods especiais de classes
getter: é um method que usa da keyword "get" para retornar/mostrar um valor de objeto/classe de forma dinâmica. Ou seja, de um valor que ainda não foi definido.
As funções criadas com o get não podem ter nenhum parâmetro.
setter: é um method que usa a keyword "set" e serve para criar/alterar um valor dentro de um objeto/classe.
As funções criadas com o set só podem ter exatamente 1 parâmetro.
Só deixando claro, get e set são keywords que servem para criar funções com propósitos específicos.

##Exemplo:
class Aluno {
// usando um constructor para definir as key/values iniciais.
constructor(nome, curso, semestre){
this.nome = nome,
this.curso = curso,
this.semestre = semestre
}
// criando um method para retornar o nome do aluno antes mesmo dele ser definido
get nomeAluno(){
return this.nome
}
//criando um nome para o aluno se ele não existir e alterando se existir
set nomeAluno(nomeAluno) {
this.nome = nomeAluno
}
}

let lucas = new Aluno('', 'Engenharia', 5)
lucas.nomeAluno = 'Lucas'
console.log(lucas.nome) //Lucas
lucas.nomeAluno = 'Abacate';
console.log(lucas.nomeAluno) // "Abacate" usando getter

##

➽ Class inheritance
Lembra do que falamos sobre prototypes? Vamos usar isso aqui.
Basicamente para fazer uma classe herdar methods e properties de outra classe basta você usar a keyword "extends".
##Ex:
//classe normal
class Animal {
constructor(name) {
this.speed = 0;
this.name = name;
}
run(speed) {
this.speed = speed;
alert(`${this.name} runs with speed ${this.speed}.`);
}
}
//criação de uma classe que herda coisas de "Animal"
class Rabbit extends Animal {
hide() {
alert(`${this.name} hides!`);
}
}

let rabbit = new Rabbit("White Rabbit");
rabbit.run(5); // White Rabbit runs with speed 5.
rabbit.hide(); // White Rabbit hides!

##

Entrentanto as coisas não são tão simples. Repare que essa classe "Rabbit" não possue um constructor. E se possuisse ? Bom, ocorreria um conflito do "this".
Basicamente você precisa saber de 3 coisas:

1. quando você criar cria uma classe sem constructor, ele existe, mas está vazia.
2. a classe que herdou coisas sempre vai dar prioridade a seus proprios elementos, só depois usando os herdados(caso tenham o mesmo nome)
3. Para que "o que herdou" se refira a seu ancestral utiliza-se o method super()
   ---> Dessa forma, se a classe ancestral e a descendente possuem o mesmo nome em suas properties, você que usar a do ancestral, e fazer usando o "super(prop)";
   ##Ex:
   class Animal {
   constructor(name) {
   this.speed = 0;
   this.name = name;
   }
   }

class Rabbit extends Animal {
constructor(name, earLength) {
super(name); //vai usar o constructor ancestral para criar o nome
this.earLength = earLength; // property especifica dessa classe
}
}

let rabbit = new Rabbit("White Rabbit", 10);
alert(rabbit.name); // White Rabbit
alert(rabbit.earLength); // 10

##

➽ Private/protected properties and methods
É algo fundamental quando você está criando coisas complexas/ que usam ou se comunicam, protengendo elas de serem alteradas.
Uma analogia seria com uma cafeteira. Ela é um objeto complexo, tranforma a corrente alternada em corrente contínua e depois tranforma em calor e etc.
Entretanto, para o usuário isso não importa, o que importa é que ele coloca água em um lugar, pó em outro e então aperta um botão.
Esse é o tipo de proteção/abstração.

Internal interface – methods and properties, accessible from other methods of the class, but not from the outside.
External interface – methods and properties, accessible also from outside the class.

Para fazer essa proteção não existe um method ou função especifica. Basicamente você tem que usar seu conhecimento para tal.
Usar condicionais para controlar o valor de algo, usar um get e não usar um set para tornar a property read-only. Etc;
Na realidade, não há necessidade de usar set/get, desde que você tenha um controle maior no momento de criar a função.
OBS: é uma convenção usar "\_" no nome de properties protegidas;
##Ex:
class CoffeeMachine {
//criando property "universal"/padrão.
\_waterAmount = 0;
//fazendo o controle de qualidade de uma property com o "set" e condicionais
set waterAmount(value) {
if (value < 0) {
value = 0;
}
this.\_waterAmount = value;
}
//faz o output da quantidade de agua. Repare que tem o mesmo nome que o "setter"
get waterAmount() {
return this.\_waterAmount;
}

constructor(power) {
this.\_power = power;
}
get power(){
return this.\_power;
}

}

// create the coffee machine
let cafeteira = new CoffeeMachine(100);

cafeteira.waterAmount = -10;
alert(cafeteira.waterAmount)
cafeteira.waterAmount = 23;
alert(cafeteira.waterAmount)
alert(cafeteira.power);
cafeteira.power = 200;
alert(cafeteira.power);

##

➽ OBS:
------> instanceof
É um operador(não é um method) que nos permite checar se uma variável pertence a uma classe
##Ex:
let arr = [1, 2, 3];
alert( arr instanceof Array ); // true porque "arr" é da built-in class "Array"
alert( arr instanceof Object ); // true porque "arr" é da built-in class "Array" que é da built-in class "Object"

##

------> Mixins
Em JS objetos só podem herdar coisas de um único objeto. minixs são como catalogadores de utilidades que são usados para dar mais funicionalidades a objetos que já tem propotype.
Basicamente, quando "objNovo" herda de "objVelho" ele troca coloca seu prototype como sendo o mesmo de "objVelho".
Se nos queremos que "objNovo" tenha outras funcionalidades externas/importadas podemos usar mixins:
##Ex:
// criando um mixin
let coisasUteis = {
sayHi() {
alert(`Hello ${this.name}`);
},
sayBye() {
alert(`Bye ${this.name}`);
}
};

//Classe ancestral
class Person{
constructor(name){
this.name = name;
}
miracle(){
alert("A b a c a t e")
}
}
// classe descendente:
class User extends Person{
perceive(){
super.miracle();
}
constructor(name){
super(name);
}
}
//estamos "colando" diretamente ao prototype de "User" um conjunto de código
Object.assign(User.prototype, coisasUteis);

//Agora um objeto da classe User pode fazer uso das "coisasUteis" mesmo já tendo herado algo.
new User("zezin").sayHi();
new User("whatever").miracle();

##

⚪ Error handling ⚪
É impossivel fazer codigo sem erro. O intuito de cuidar dos erros e passar um auxilio personalizado ao usuário e impedir que todo o script morra.
Como já dito, se um erro ocorre Todo o script/codigo para. Isso é ruim. Nós queremos fazer com que o código continue apesar dos erros. Para isso podemos utilizar o "try...catch"

➽ try...catch:
É uma especie de condicional que funciona sincronamente, para cuidar de erros.
##syntax
try {
//code to run
alert('Start of try runs');
alert('End of try runs');

} catch (err) {
//error handling
alert('This "Catch" is ignored, because there are no errors');
}

##

O argumento "err" pode ter qualquer nome. Ele na realidade representa um objeto que vai possuir informações sobre o erro.
Existem alguns methods que podemos usar nesse objeto:

- err.name; // Error name
- err.message; // Textual message about error details.

Nós também podemos criar pontos de verificação e se o código não passar neles podemos "jogar" um erro usando throw. Normalmente você também precisa criar um error objet ao usar o "Error", "SyntaxError" ou etc
##Ex:
let json = '{ "age": 30 }';
try{
let user = JSON.parse(json);
if(!user.name){
throw new SyntaxError("Dados incompletos. Nome não disponível");
}
alert("user.name); //só vai ser executado se o throw não ocorrer. Ele é como se fosse um return.
} catch(err){
alert("O seguinte erro ocorreu: " + err.message);
}

##

➽ finally:
Assim como em python, também existe a keyword "finally". Ela vai ser executada tamnto depois do try quanto depois do catch.
OBS: Existe um built-in error object chamado de "Error"
OBS: Como erros são objetos com informações, você pode criar e estender respostas para certos tipos de erro. Tendo cuidado quando for usar a property "name", não esquecendo de usar o "super()".

⚪ Promises, async/await ⚪

➽➽➽ Callbacks:
No mundo real as coisas não ocorrem imediatamente. Por exemplo, se seu computador é lento e você quer fehcar o google e abrir um jogo, o jogo não vai esperar o google fechar para poder abrir.
Podemos dizer que a atividade de fechar o google não ocorre imediatamente, e o jogo não espera ela acontecer.
Vamos trazer isso para o javaScript:
##Ex com o carregamento de scripts.
//função que vai criar um tag <script> no html, dado o path até a .js file
function loadScript(src){
let script = document.createElement('script');
script.src = src; //src é uma property do elemento script, que é representado pela variável script
document.head.append(script);
//inicando o carregamento do script com esse path
loadScript('/my/script.js');
//dentro desse script existe uma função chamada de func123();
func123(); //gera uma erro, pois o carregamento não ocorre automaticamente
}

##

Para executar a função desse script no exato momento em que ele carregar precisamos de um callback, uma afirmação que diz: "pronto, já pode rodar".
Para criar/gerar uma calback você precisa:

1. Na função que precisa do callback(loadScript) adicinar outro parâmetro, que será o callback
2. usar o ".onload" method para rodar o calback, usando a keyword "callback()"
3. Quando chamar a função, detalhar como a callbakc funcionará:
   ##Ex:
   //modificando a função para que ela possa usar um callback
   function loadScript(src, callback) {
   let script = document.createElement('script');
   script.src = src;
   script.onload = () => callback(script);
   //quando o script carregar, você vai rodar a função chamada de callback e passar esse próprio script como argumento
   script.onerror = () => callback(new Error("Ocorreu um erro durante o carregamento do script"));
   document.head.append(script);
   }
   //Criando manualmente a callback dessa função. Quando o script carregar essa função vai rodar.
   function callback(script){
   alert(`Cool, the script ${script.src} is loaded`);
   alert( \_ ); // function declared in the loaded script
   }

loadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', callback);

##

Normalmente você não precisa criar uma função separada chamada callback. Normalemente ela é uma arrow function anonima.

A ideia de callback é: eu vou executar isso necessáriamente depois disso. Em uma espécie de ordem/cadeia.
OBS: só deixando claro, callback Não é uma keyword, você pode trocar o nome callback por qualquer outra coisa.

Entretando existe um problema com esse código, ele não tem controle sobre erros. Veja uma maneira mais consisa e "correta":

##

function loadScript(src, callback) {
let script = document.createElement('script');
script.src = src;
//A função callback vai ter dois parametros agora. O primeiro é um erro e o segundo o script
//Se o script conseguir carregar, o primeiro argumento é nulo e tudo ocorre naturalmente
script.onload = () => callback(null, script);
//se o ocorrer erro, só vamos passar o primeir argumento, e ele vai ser um erro.
script.onerror = () => callback(new Error());
document.head.append(script);
}
// aqui passamos a função callback como uma arrow anonymous function.
//repare que passamos dois argumentos (o erro, o script).
loadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', (error, script) => {
if(error){
alert("Deu pepino");
}else{
alert(`Cool, the script ${script.src} is loaded`);
alert( \_ ); // function declared in the loaded script
}
});

##

➽➽➽ Promises:
Imagine que você é um cantor e seus fãs enchem seu saco por música novas. Daí você promete pra eles que você vai mandar assim que estiver pronto, mas eles precisam assinar uma ata ou coisa do tipo.
Essa analogia reflete o seguinte conceito:
o cantor -> “producing code” == vai fazer algo que demora (asincrono)
os fãs -> consuming code” == vão pegar o resultado do “producing code” e fazer alguma coisa
a ata -> é a "Promise" que liga os dois códigos

Promises são objetos built-in do JS e noramlemente tem essa estrutura:

##

let promise = new Promise(function(resolve, reject) {
// colocamos nosso código aqui (“producing code”)
});

##

resolve e reject são callbacks (funções) criados pelo JS.
resolve(value) — se o código roda normalmente, vai retornar o "value"
reject(error) — se algum erro ocorre, "error" is the error object

Quando você cria uma "promise" usando new Promise, você tem "estados" e "resultados"
inicialmente o "state" é pendente -> se tudo ocorre bem: "fulfilled" -> se não: "rejected"
inicialmente o "result" é undefined -> se tudo ocorre bem passa a ser o value de resolve(value) -> se não, é o erro de reject(error).
OBS: só pode existir um "resolve" ou um "reject" mas você pode escrever os dois sem problemas, desde que você faça uma condional.
##Ex:
let promise = new Promise(function(resolve, reject) {
// O código abaixo começa a executar automaticamente quando a promise é declarada/construida
//code:
setTimeout(() => resolve(alert("done")), 1000);

##

---> methods de propagação:
Você já tem a ata, e já produziu a musica, agora você só precisa enviar ela para os fãs, mas como?
Usando um dos methods: .then, .catch, .finally
O ".then" é o mais usado/universal. Você usa da seguinte forma:

##

promise.then(
function(result) {},
function(error) {}
);
//a primeira função vai ser executada se a promessa retornar um valor (for resolvida)
//a primeira função vai ser executada se a promessa retornar um erro (for rejeitada)

##

.catch(f) == .then(null, f)

.finally serve para o mesmo propósito que em try {...} catch {...}

##Ex:
alert("inicio do código");
let promise = new Promise((resolve, reject) => {
setTimeout(() => resolve("result"), 2000)
})
promise.finally(() => alert("Promise ready"))
promise.then(result => alert(result)); // <-- .then handles the result

##

Vamos usar promises para reescrever o exemplo do carregamento de scripts, que usavam callbacks.

##

function loadScript(src) {
return new Promise(function(resolve, reject) {
let script = document.createElement('script');
script.src = src;
//basicamente, podemos escrever as duas. Mas devemos fazer uma espécie de condicional
script.onload = () => resolve(script);
script.onerror = () => reject(new Error(`Script load error for ${src}`));

    document.head.append(script);

});
}

let promise = loadScript("https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js");

promise.then(
script => alert("O script foi carregado"),
error => alert(`O seguinte erro aconteceu: ${error.message}`)
);
promise.finally(() => alert('finalização do processo'));

##

➽➽➽ promise chaining:
Se você tem uma sequencia de processos assíncronos e quer interligar eles, com promises você faz isso de maneira simples. Basta chamar o ".then" dessa promessa.
##Ex:
new Promise(function(resolve, reject) {
setTimeout(() => resolve(1), 1000); // promessa inicial
}).then(function(result) { //segunda promessa
alert(result); // 1
return result \* 2;

}).then(function(result) { //terceira promessa
alert(result); // 2
return result _ 2;
}).then(function(result) { //quarta promessa
alert(result); // 4
return result _ 2;
});

##

repare que não existe "espaços" entre os .then. Eles estão: .then().then().then().then().then()

----> fetch example:
Normalmente promises são usadas em network requests e você pode trabalhar com elas de diversas maneiras. Vamos ver um modo "vanilla" de lidar com o http request "fetch".
let promise = fetch(url); vai fazer uma request dada uma url e vai resolver(retornar) uma resposta incompleta (uma confirmação de conexão) e depois uma completa (com os dados)
Para que você possa usar o conteúdoimediatamente após ele ser carregar você deve usar: .then(//alguma função)
##Ex:
//criando um user
let user = {
name: "dFLPp"
}
//fazendo uma request ao github
fetch(`https://api.github.com/users/${user.name}`)
// carregando a respose em .json
.then(response => response.json())
.catch(err => alert(err)) //opcional mas importante. Error handling
// mostrando a imagem do perfil do user no github por 3s
.then(githubUser => {
let img = document.createElement('img');
img.src = githubUser.avatar_url;
document.body.append(img);

    setTimeout(() => img.remove(), 3000);

});

##

Ou seja, apartir de função/chamada assíncrona (o fetch) precisamos usar .then para executar código imediatamente após ele (nem antes nem muito depois).
2 OBS:

1. Esse código é totalmente funcional mas é preferível separar ele em funções. De modo que as funcionalidades possam ser reusadas
2. O error handling é feito ao usar o .catch. O ".catch" pode ser usado para cuidar de qualquer tipo de erro quando em promises.

-> Basicamente você criar um novo objeto/promise e para criar atividades imediatamente após elas você usa o ".then" e coloca o ".catch" nos lugares onde você quer tratar os erros.
-> Nós podemos finalizar/encerrar uma promessa ao resolver o problema e retornar um valor com resolve(value) ou tratar algum erro, caso ocorra, com reject(error)
-> Além disso, repare que poderiamos tentar fazer esse código anterior usando callbacks, mas as promisses são tão superiores que nem valhe a pena.

Existem ainda 6 methods que podem ser usados em promises. Só vou citar o "Promise.all". Ele serve para esperar um conjunto de processos assíncronos terminarem para só então dar a resposta.
##Ex:
//urls que podem ser acessadas pela função fetch
let urls = [
'https://api.github.com/users/iliakan',
'https://api.github.com/users/remy',
'https://api.github.com/users/jeresig'
];

// vai iterar sobre uma lista usando o .map.
// É super recomendado entender como usar o .map();
let requests = urls.map(url => fetch(url));

// Promise.all vai esperar todas as promisses se completarem
Promise.all(requests)
.then(responses => responses.forEach(
response => alert(`${response.url}: ${response.status}`)
));
//essa ultima parte ficou confusa, porém basta você saber que "responses" é um nome qualquer. Ela só representa o resultado da promessa inicial.

##

-------> OBS: “Promisification” é conversão (através de uma função) de uma função que aceita callbacks em uma função que retornar promises.

➽➽➽ Async/await:
É um modo mais simples de se escrever promessas.
Usa-se a keyword "async" na frente de uma função para dizer que ela Sempre retorna uma promessa. No exemplo a seguir percebe-se que a função passa a ser assíncrona

##

async function f() {
return 1;
}
f().then(alert); // 1
alert("abacate")

##

Usar async é mais simples/menos confuso pois, como todas as funções declaradas com async retornam necessáriamente uma promessa, podemos usar "return 1" ao invés de return Promise.resolve(1);
Existe ainda a keyword "await". Ela só pode ser usada dentro de funções que são "async" e ela faz o javaScript pausar a execução de algo até que a promessa returne algo.
Não é obrigatorio, mas na maioria das vezes, você deve usar: "let a = await ..." ao invés de usar "await ..." diretamente.
##Ex:
async function f() {
let promise = new Promise((resolve, reject) => {
setTimeout(() => resolve("done!"), 1000)
});
let result = await promise; // a execução da função Para aqui e só volta quando a promise retornar algo.
alert(result); // "done!"
}
f();

##

O await pode ser comparado ao .then. Eles tem o mesmo proprósito/utilidade.

Usando async/await vamos tentar reconstruir aquele exemplo de mostrar o icone do github de um user.

##

let user = {
name: "dFLPp"
}

async function showAvatar(name) {
//faz a request
let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);
//"traduz" a request em json usável pelo código
let githubUser = await githubResponse.json();

//mostra o ícone no html
let img = document.createElement('img');
img.src = githubUser.avatar_url;
img.className = "promise-avatar-example";
document.body.append(img);

//espera 3s para apagar o icone
await new Promise((resolve, reject) => setTimeout(resolve, 3000));
img.remove();
return githubUser;
}

showAvatar(user.name);

##

-------> Error handling:
Quanto estamos trabalhando com async/await nós estamos dentro de funções, então é mais prático e fácil usar o try..catch ao invés de usar o .catch (como acontecia em promises).
##Ex:
async function f() {
try {
let response = await fetch('/no-user-here');
let user = await response.json();
} catch(err) {
// catches errors both in fetch and response.json
alert(err);
}
}

f();

##

➽➽➽ Recapitulação:

Vimos 3 formas de interação com eventos/processos assíncronos e demos alguns exemplos, e entre eles como usar o fetch() method para pegar informações através de urls

1. Os primeiros foram as callbacks. Callbacks se referem a funções que devem ser executadas imetiadatamente após as outras. Para isso você passa uma função como argumento da outra.
   Para tratar erros com callbacks podemos usar tanto o try..catch quanto usar built-in methods como: "onload" ou "onerror"

2.Depois analizamos a fundo promises. Como promises nós podemos trabalhas com eventos assíncronos em cadeia de maneira mais simples. Para criar uma promise você deve usar o criar um objeto através built-in method Promise().
let promessa = Promise(function(resolve, reject) {
// colocamos nosso código aqui
});
Dessa forma, quando o código terminar de rodar ele retorna um valor com o method "resolve()" ou retorna um erro com o "reject()". Ainda é possível "concatenar" divesar promessas com o ".then()" e faz o controle de erro ao usar o ".catch(alert)"

3. E por fim vimos a maneira mais moderna/recomenda de se trabalhar com eventos assíncronos, que é com async/await. Quando você usa a keyword "async" para criar uma função, ela sempre retornará uma promise, dessa forma você pode usar .then e os conceitos vistos em promises. Porém você também pode usar a keyword await, ela tem o mesmo propósito que o .then e vai pausar o código para esperar a promise retornar algo.  
   PAra tratar erros aqui podemos voltar a usar try..catch, ou continuar a usar .catch. Eu, partircularmente, achei o conceito de promises e os methods usados mais lógicos/compreensíveis. Acho que usar .then() ainda é mais facil que usar "await", entretando é a prática que faz o programador então...

⚪ Generators ⚪

generators ou generator functions são funções especiais que podem retornar(yield) vários valores, um depois do outro (em sequencia), diferentemente das funções normais que só retornam um valor.
Para você criar uma generator function você usa a keyword "function*", com um asterísco no final. O resultado dessa função é um objeto especial chamadado de generator object.
O princípal method de um generator é o "next()". Quando você chama ele, você executa a função até encontrar a keyword "yield", depois disso retorna um valor e pausa a função, contínando com o código.
Quando você fizer o next() novamente, a execução vai voltar de onde paraou e vai até a achar ou "yield";
yield não é um substituto do return. O yield serve para "fragmentar" a função de modo que ela execute em momentos específicos e retorne valores diferentes.
#Ex:
function* generateSequence() {
yield 1;
yield 2;
return 3;
}

let generator = generateSequence();
//até aqui, a função não é executada, pois nenhum next() foi usado

let one = generator.next();
alert(JSON.stringify(one));
//acima nos executamos a fução pela primeira vez. Mas ela não vai executar completamente, só uma parte
//aqui podemos fazer uso desse "resultado parcial" da função

//Tudo bem, agora queremos o resultado de outra parte da função. Para isso:
let two = generator.next();
alert(JSON.stringify(two)); // {value: 2, done: false}

//E se quisermos continuar com a próxima (e ultima) parte:
let three = generator.next();
alert(JSON.stringify(three)); // {value: 3, done: true}

##

Nesse ultimo alert você perceberá que a property done passou a ser true. Isso acontece porque o "return" existe.
O JS só sabe que um generator acabou se você usar a keyword return.

Generators são iteráveis, podendo usar todos os methods que já foram citados sobre iterators.

Normalmente generators são usados para criar funções, objetos, e códigos que não são iteráveis em coisas iteráveis. Você consegue faz isso ao usar o built-in method \*[Symbol.iterator]() {}
#Ex:
let range = {
from: 1,
to: 5,

_[Symbol.iterator]() { // a shorthand for [Symbol.iterator]: function_()
for(let value = this.from; value <= this.to; value++) {
yield value;
}
}
};

alert( [...range] ); // 1,2,3,4,5

##

➽➽➽ Async iteration and generators:
O nome é bem auto-explicativo, é o ato de realizar iterações assincronamente.
Um exemplo básico seria: Quando o usuário decidir fazer uma compra você pode fazer ele passar uma bateria de informações para validação.
Isso é a assíncrono porque a compra só pode acontecer depois que o user colocar os dados
Isso é um iterator por que dado uma sequencia de perguntas, estamos iterando sobre elas e recebendo respostas.

Veja uma comparação:
Iterators Async iterators
Object method to provide iterator Symbol.iterator symbol.asyncIterator
next() return value is any value Promise
to loop, use for..of for await..of
Declaration function* async function*

⚪ Modules ⚪
Modules são arquivos que podem ser importados ou importandos, permitindo usar códigos em outros arquivos sem ter que entende-los ou reescreve-los
Ex: eu tenho dois arquivos no mesmo diretório: sayHi.js e main.js. Se eu quiser usar uma função, ou uma variável, generators ou etc, eu preciso exportar ela (export)
Já em "main.js" eu quero usar algo não nativo, então eu preciso importar (import)
##Ex:
// 📁 sayHi.js
export function sayHi(user) {
alert(`Hello, ${user}!`);
}

// 📁 main.js
import {sayHi} from './sayHi.js';
sayHi('John'); // Hello, John!

##

Modules funionam somente com HTTP(S). Ou seja, você precisa emular um servidor para que você possa usar modules. Emular/gerar um dev server é algo comum/recorrente em web dev moderna. Existem extensões no VS code e tutoriais simples que indicam o "como criar".

Para que você possa integrar scripts no se HTML você deve usar type="module" na tag <script> aleḿ disso, se você quer importar um module externo (site ou etc) você usar o "src"
##Ex:

<script type="module" src="http://another-site.com/their.js"></script>

##

Existem alguns outros tópicos:
-> "import \*" vai importar todas as coisas que foram exportadas no arquivo alvo
-> tanto no export quanto no import você pode utilizar "as" para se referir a uma função ou coisa específico.
-> import deve estar no "top level" (não pode estar funções, condicionais, blocos de código no geral)
##Ex:
// 📁 say.js
export function sayHi() { ... }
export function sayBye() { ... }
export function becomeSilent() { ... }

// 📁 main.js
import \* as say from './say.js';

say.sayHi('John');
say.sayBye('John');

##

OBS: você pode usar "export default abacate(){//code}" para exportar essa função como padrão desse arquivo, dessa forma você pode se referir a ela como default ao invés do nome.
➽ Build tools:
Em projetos reais, normalmente não se utilizam modules na sua versão "Pura", uma ferramenta chamada de bundler vai organizar e otimizar os modules de modo que não ocorram erros e que o app/site não fique pessado.
Por exemplo, supondo que nós utilizamos a bundler "Webpack", ao invés de fazer vários imports no html ou em outro .js, Nos podemos fazes esses vários imports no arquivo especial do Webpack e ele então vai otimizar o código.
Dessa forma ao invés de fazer 5 imports no meu html, eu faço somente 1 (que é o arquivo especial fornecido pelo bundler)

➽ Dynamic imports
Tem sentido literal. O intúito é fazer o import de modules ou files de maneira "ao vivo" (on-demand), sendo necessário usar o method "import()".
Na maioria das vezes, se você quer carregar um import em um momento específico, é poque você está usando async. Veja o exemplo que combina os dois conceitos:
##Ex:
// 📁 say.js
export function hi() {
alert(`Hello`);
}
export function bye() {
alert(`Bye`);
}
export default function() {
alert("Module loaded (export default)!");
}

// 📁 index.html

<!doctype html>
<script>
  async function load() {		// só se pode usar await em função async
    let say = await import('./say.js'); // você faz await no "import()"; 
    say.hi(); // Hello!
    say.bye(); // Bye!
    say.default(); // Module loaded (export default)!
  }
</script>

<button onclick="load()">Click me</button>

##

⚪ Miscellaneous ⚪

➽ Proxy:
O method Proxy atua como um wrapper de um objeto, que intercepta operações como ler/escrever dados (é uma camada de segurança)
Syntax: "let proxy = new Proxy(target, handler)" onde "target" é o objeto a ser "protegido" e "handler" é um method com armadilhas/mecanismos de seguraça.
Dentro do handler você usa outros methods como get(para ler dados) e set(para escrever dados)
##Ex:
let numbers = [0, 1, 2];

numbers = new Proxy(numbers, {
get(target, prop) {
if (prop in target) {
//OBS: prop se refere automaticamente aos elementos do objeto
return target[prop];
} else {
return 0; // default value
}
}
});

alert( numbers[1] ); //Se o valor existe dentro do objeto, você o mostra
alert( numbers[123] ); //Nesse caso ele retorna 0

##

## Ex mais complexo:

let user = {
name: "John",
\_password: "\*\*\*"
};

user = new Proxy(user, {
get(target, prop) {
if (prop.startsWith('_')) {
throw new Error("Access denied");
}
let value = target[prop];
return (typeof value === 'function') ? value.bind(target) : value; // (\*)
},
set(target, prop, val) { // to intercept property writing
if (prop.startsWith('_')) {
throw new Error("Access denied");
} else {
target[prop] = val;
return true;
}
},
deleteProperty(target, prop) { // to intercept property deletion
if (prop.startsWith('_')) {
throw new Error("Access denied");
} else {
delete target[prop];
return true;
}
},
ownKeys(target) { // to intercept property list
return Object.keys(target).filter(key => !key.startsWith('_'));
}
});

// "get" doesn't allow to read \_password
try {
alert(user.\_password); // Error: Access denied
} catch(e) { alert(e.message); }

// "set" doesn't allow to write \_password
try {
user.\_password = "test"; // Error: Access denied
} catch(e) { alert(e.message); }

// "deleteProperty" doesn't allow to delete \_password
try {
delete user.\_password; // Error: Access denied
} catch(e) { alert(e.message); }

// "ownKeys" filters out \_password
for(let key in user) alert(key); // name

##
